% A ConTeXt document [master document: literateProgs.tex]

\startchapter[title=The Lua Rendering Engine]

\startLuaCode

-- We need a simple Lua based template engine
-- Our template engine has been inspired by:
--   https://john.nachtimwald.com/2014/08/06/using-lua-as-a-templating-engine/
-- (via the minLua JoyLoL template engine)

function litProgs.renderNextChunk(prevChunk, renderedText, curTemplate)
  local result = ""
  
  if prevChunk
    and type(prevChunk) == 'string'
    and 0 < #prevChunk then
    table_insert(renderedText, prevChunk)
  end
  
  if type(curTemplate) == 'string' and (0 < #curTemplate) then
    if curTemplate:find('{{') then
      local position  = 1
      local textChunk = curTemplate:match('^.*{{', position)
      if textChunk then 
        local textChunkLen = #textChunk
        textChunk = textChunk:sub(1, textChunkLen-2)
        if 0 < #textChunk then table_insert(renderedText, textChunk) end
        position = position + textChunkLen
      end
      
      local luaChunk = curTemplate:match('^.+}}', position)
      if luaChunk then
        local luaChunkLen = #luaChunk
        luaChunk = luaChunk:sub(1, luaChunkLen-2)
        position = position + luaChunkLen
        curTemplate = curTemplate:sub(position, #curTemplate)
        local newChunk = ""
        if not luaChunk:match('^%s*$') then
          -- consider using an PCall here....
          local luaFunc, errMessage = load(luaChunk)
          if luaFunc then
            newChunk = luaFunc(litProgs)
          end
        end
        result = litProgs.renderNextChunk(newChunk, renderedText, curTemplate)
      end
    else -- there is no '{{' in the template
      table_insert(renderedText, curTemplate)
      result = table_concat(renderedText)
    end
  else
    -- nothing to do...
    result = table_concat(renderedText)
  end
  return result
end

function litProgs.render(aTemplate)
  return litProgs.renderNextChunk("", { }, aTemplate)
end

-- Now we need the code that captures and creates a given code/file type 

local function renderFile(aFilePath, baseTemplate)
  local outFile = io.open(aFilePath, 'w')
  --outFile:write(pp.write(litProgs))
  local renderedBaseTemplate = litProgs.renderNextChunk("", {}, baseTemplate)
  --outFile:write('\n--------------\n')
  outFile:write(renderedBaseTemplate)
  outFile:close()
end

\stopLuaCode

\section[title=Testing the rendering engine]

Given the moderate complexity of the Lua rendering engine, we need to 
provide justifications of its correctness. While Theoretical Computer 
Science does provide tools which could be used to attempt to \emph{prove} 
the above Lua code correct these tools are not really integral to the Lua 
language. Our primary aim in creating this cycle of tools is to develop 
the JoyLoL language in which these tools of \emph{deductive} proof are 
integral, to the language. In the JoyLoL language, the distinction between 
deductive proof and inductive testing is much clearer. For the moment we 
will only provide \quote{inductive} tests of correctness for the above Lua 
code. 

\def\startTestSuite{\subsection}
\def\stopTestSuite{\relax}
\def\startTestCase{\subsubsection}
\def\stopTestCase{\relax}
\definetyping[LuaTest]
\setuptyping[LuaTest][option=lua]

\startTestSuite[title=renderNextChunk]

At the moment, the critical complexity is contained in the 
\type{renderNextChunk} function, so we will focus upon testing this 
function. Our strategy will be simple, we will invoke the 
\type{renderNextChunk} function on a number of example arguments, chosen 
to ensure all of the \quote{main} paths of the function are taken in at 
least one of the invocations. Associated with each invocation, we will 
make a number of simple assertions about that invocationâ€™s returned value. 
If all of the assertions are true, we consider the \type{renderNextChunk} 
function \quote{inductively} correct. 

\startTestCase[title=should stop]

The \type{renderNextChunk} function is recursive, so in our first test 
case, it is important to test that this recursion \emph{does} stop. To do 
this we provide arguments which have a simple previous chunk 
(\type{prevChunk}), a simple previously rendered text 
(\type{renderedText}), as well as an \emph{empty} currently remaining 
template (\type{curTemplate}). 

\startLuaTest
  local result = renderNextChunk("this is a simple text", { }, "")
\stopLuaTest

The result of this invocation, should be a Lua string which consists 
of the \type{preChunk}. 

\startLuaTest
  assert_string(result)
  assert_equal("this is a simple text", result)
\stopLuaTest
\stopTestCase

\startTestCase[title=should combine previously rendered text]

We next need to show that more complex collections of previously rendered 
text are handled correctly. 

\startLuaTest
  local result = renderNextChunk("this is a final text", {
    "this is the first text",
    "this is the second text"
  }, "")
\stopLuaTest

The result should be the texts contained in the rendered text together 
with the \type{prevChunck} all concatenated \emph{with no additional 
white-space}. 

\startLuaTest
  assert_string(result)
  assert_equal(
    "this is the first textthis is the second textthis is a final text",
    result
  )
\stopLuaTest

\stopTestCase

\stopTestSuite

\stopchapter