% A ConTeXt document [master document: literateProgs.tex]

\startchapter[title=The capture and manipulation of code]

All of our literate programming code capture environments are enhanced 
versions of the \ConTeXt\ \type{typing} environment. When creating 
\quote{standard} \ConTeXt\ environments the two commands, 
\type{\defineXXX} and \type{\setupXXX}, are critical to their overall use. 

\startTestSuite[defineLitProgs]

We begin by defining the \type{\defineLitProgs} command. This command is a 
simple enhancement of the \type{\definetyping} command, so we, 
essentially, define the \type{\defineLitProgs} command to call the 
\type{\definetyping} command.

However, the \type{\definetyping} command takes a variable number of up to 
three of arguments. This means that our definition of 
\type{\defineLitProgs} must also be able to deal with the same number of 
variable arguments. We use \ConTeXt's \type{\dotripleempty} command to 
provide the simplest and most explicit way of dealing with up to three 
variable arguments. A side-effect of our explicit pattern is that we 
provide the user with more appropriate error messages. 

The \type{\dotripleempty} command scans the token stream expecting a 
command plus up to three \quote{[} \quote{]} delimited arguments. It then 
sets one of the \type{\ifXXXargument} tests to true, depending upon how 
many arguments it has found. The \quote{real} work gets done in either the 
\type{\doDefineLitProgsSingle}, \type{\doDefineLitProgsDouble} or 
\type{\doDefineLitProgsTriple} commands, which explicitly expect either 
one, two or three arguments respectively. The \type{\doDefineLitProgsZero} 
command provides an appropriate error message, if the user has provided no 
arguments. The \type{\doDefineLitProgs} command simply manages the choice 
of the appropriate \type{\doDefineLitProgsXXX} command. 

Since we are enhancing the \type{typing} environment using lua code, the 
\type{\doDfineLitProgsSingle}, \type{\doDefineLitProgsDouble} and 
\type{\doDefineLitProgsTriple} commands make use of the 
\type{\fixStartLitProgs} and \type{\fixStopLitProgs} commands to layer in 
our enhancements. These two commands will be defined below. Similarly, we 
need to define a setup command corresponding to our new code type. We do 
this using the \type{defineLitProgsSetup} command, also to be defined 
below. Finally for each code type we would like a corresponding 
\type{createXXXFile} macro to write the accumulated text for a given code 
type out into a file. 

% see: http://wiki.contextgarden.net/Commands_with_optional_arguments

\startMkIVCode
\unexpanded\def\defineLitProgs{%
  \dotripleempty\doDefineLitProgs%
}

\unexpanded\def\doDefineLitProgs[#1][#2][#3]{%
  \ifthirdargument%
    \doDefineLitProgsTriple{#1}{#2}{#3}%
  \else\ifsecondargument%
    \doDefineLitProgsDouble{#1}{#2}%
  \else\iffirstargument%
    \doDefineLitProgsSingle{#1}%
  \else%
    \doDefineLitProgsZero%
  \fi\fi\fi%
}

\unexpanded\def\doDefineLitProgsTriple#1#2#3{
  \definetyping[#1][#2][#3]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsDouble#1#2{
  \definetyping[#1][#2]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsSingle#1{
  \definetyping[#1]
  \fixLitProgs{#1}
}

\unexpanded\def\doDefineLitProgsZero{
  \errmessage{
    \string\\defineLitProgs
    requires at least one argument,
    you have provided none.
  }
}
\stopMkIVCode

\startTestCase[should call all associated macros]

We assert that the \type{\defineLitProgs} macro actually defines all of 
the required macros. 

\startConTest
\begingroup
  \mockContextMacro{doDefineLitProgs}{3}
  \defineLitProgs[TestCode]
  \assertMacroExpanded{doDefineLitProgs}{}
\endgroup
\stopConTest

\startConTest
\begingroup
  \traceContextMacro{doDefineLitProgs}{3}
  \mockTexMacro{doDefineLitProgsTriple}{3}
  \mockTexMacro{doDefineLitProgsDouble}{2}
  \mockTexMacro{doDefineLitProgsSingle}{1}
  \mockTexMacro{doDefineLitProgsZero}{0}
  \firstargumentfalse
  \secondargumentfalse
  \thirdargumentfalse
  \assertNoFirstArgument{first}
  \assertNoSecondArgument{first}
  \assertNoThirdArgument{first}
  \defineLitProgs[AFirstArg]
  \assertFirstArgument{second}
  \assertNoSecondArgument{second}
  \assertNoThirdArgument{second}
  \assertMacroExpanded{doDefineLitProgsSingle}{}
\endgroup
\stopConTest

\startConTest
\begingroup
  \mockTexMacro{fixLitProgs}{1}
  \defineLitProgs[TestCode]
  \assertDefined{startTestCode}{}
  \assertDefined{stopTestCode}{}
  \assertMacroExpanded{fixLitProgs}{}
\endgroup
\stopConTest

\stopTestCase

\startTestCase[should define associated marcros]

\startConTest
\begingroup
  \defineLitProgs[TestCode]
  \assertDefined{startTestCode}{}
  \assertDefined{stopTestCode}{}
\endgroup
\stopConTest
\stopTestCase

\stopTestSuite

\startTestSuite[fixing literate programming environments]

Having provided the \ConTeXt\ code required to deal with variable 
arguments, we now need to provide the code required to \quote{fix} the 
\type{\startXXX} and \type{\stopXXX} commands automatically generated by 
the \type{\defintyping} command. We do this with the \type{\fixLitProgs} 
command. 

This command essentially \quote{wraps} the original \type{\startXXX} and 
\type{\stopXXX} commands with calls to an appropriate lua function 
(defined below). To do this our \quote{fix} command \type{\let}'s an 
\type{\oldXXX} command to \emph{be} the original command, and then 
redefine the original command to make the call into the lua code and then 
call the new \type{\oldXXX} command. Order here is critical as the 
\type{typing} environment is scanning for the exact token \type{\stopXXX}. 
Since all of these new commands are generated from the user's supplied 
code name, we make use of the Literate Programming Lua Renderer to 
dynamically build the required commands. 

A final complication is that our \type{\startXXX} command can take an 
optional argument which specifies a particular stream of code. If this 
optional argument is not provided, the 'default' stream will be used. We 
use an explicit variable argument pattern similar to that used to define 
\type{\defineLitProgs} above. Note that for the \type{\stopXXX} command 
things are simpler since the \type{\stopXXX} command takes no arguments. 

Finally, we need a code file creation command for each code type, 
\type{\createXXXFile}. This command takes two explicit arguments, the 
first argument is the name of the code stream, this is the same string as 
used in any of the corresponding \type{\startXXX} commands. The second 
argument is the name of the code file to be created. 

With these objectives in mind, we define the following Lua Template:

\startLuaTemplate
addTemplate(
  'fixLitProgs',
  { 'litProgsName' },
[=[
\let\oldStart{{= litProgsName }}=\start{{= litProgsName }}
\unexpanded\def\start{{= litProgsName }}{%
  \directlua{
    thirddata.literateProgs.markCodeOrigin(
      '{{= litProgsName }}'
    )
  }%
  \oldStart{{= litProgsName }}%
}
\let\oldStop{{= litProgsName }}=\stop{{= litProgsName }}
\unexpanded\def\stop{{= litProgsName }}{%
  \oldStop{{= litProgsName }}%
  \directlua{
    thirddata.literateProgs.addCode(
      '{{= litProgsName }}',
      '_typing_'
    )
  }
}
\unexpanded\def\create{{= litProgsName }}File#1#2#3{%
  \directlua{
    thirddata.literateProgs.createCodeFile(
      '{{= litProgsName }}',
      '#1',
      '#2',
      '#3'
    )
  }
}
\unexpanded\def\set{{= litProgsName }}Stream#1{%
  \directlua{
    thirddata.literateProgs.setCodeStream(
      '{{= litProgsName }}',
      '#1'
    )
  }
}
\unexpanded\def\prepend{{= litProgsName}}#1{%
  \directlua{
    thirddata.literateProgs.setPrepend(
      '{{= litProgsName }}',
      '#1'
    )
  }
}
]=]
)
\stopLuaTemplate

We now define the Lua method, \type{createFixLitProgs}, which is required 
to drive the renderer. 

\startLuaCode
local function createFixLitProgs(theLitProgsName, aTracingOn)
  local theEnv = {
    litProgsName = theLitProgsName,
    tracingOn    = aTracingOn
  }
  local templatePath = litProgs.parseTemplatePath('fixLitProgs', theEnv)
  local theTemplate  = litProgs.navigateToTemplate(templatePath)
  local result       = litProgs.renderer(theTemplate, theEnv, true)
  result             = litProgs.splitString(result)
  tex.print(result)
  return result
end

litProgs.createFixLitProgs = createFixLitProgs
\stopLuaCode

We now define the \ConTeXt\ macro which will drive the whole process 
required to fix a new Literate Programs environment. 

\startMkIVCode
\def\fixLitProgs#1{%
  \directlua{thirddata.literateProgs.createFixLitProgs('#1')}
}
\stopMkIVCode

\startTestCase[createFixLitProgs should create the correct macros]

\startLuaTest
local createFixLitProgs = thirddata.literateProgs.createFixLitProgs

local macroBody = createFixLitProgs('Test')
assert.isTable(macroBody)
assert.length(macroBody, 45)
assert.isEqual(macroBody[1],  "\\let\\oldStartTest=\\startTest")
assert.isEqual(macroBody[2],  "\\unexpanded\\def\\startTest{%")
assert.isEqual(macroBody[3],  "  \\directlua{")
assert.isEqual(macroBody[4],  "    thirddata.literateProgs.markCodeOrigin(")
assert.isEqual(macroBody[5],  "      'Test'")
assert.isEqual(macroBody[6],  "    )")
assert.isEqual(macroBody[7],  "  }%")
assert.isEqual(macroBody[8],  "  \\oldStartTest%")
assert.isEqual(macroBody[9],  "}")
assert.isEqual(macroBody[10], "\\let\\oldStopTest=\\stopTest")
assert.isEqual(macroBody[11], "\\unexpanded\\def\\stopTest{%")
assert.isEqual(macroBody[12], "  \\oldStopTest%")
assert.isEqual(macroBody[13], "  \\directlua{")
assert.isEqual(macroBody[14], "    thirddata.literateProgs.addCode(")
assert.isEqual(macroBody[15], "      'Test',")
assert.isEqual(macroBody[16], "      '_typing_'")
assert.isEqual(macroBody[17], "    )")
assert.isEqual(macroBody[18], "  }")
assert.isEqual(macroBody[19], "}")
assert.isEqual(macroBody[20], "\\unexpanded\\def\\createTestFile#1#2#3{%")
assert.isEqual(macroBody[21], "  \\directlua{")
assert.isEqual(macroBody[22], "    thirddata.literateProgs.createCodeFile(")
assert.isEqual(macroBody[23], "      'Test',")
assert.isEqual(macroBody[24], "      '#1',")
assert.isEqual(macroBody[25], "      '#2',")
assert.isEqual(macroBody[26], "      '#3'")
assert.isEqual(macroBody[27], "    )")
assert.isEqual(macroBody[28], "  }")
assert.isEqual(macroBody[29], "}")
assert.isEqual(macroBody[30], "\\unexpanded\\def\\setTestStream#1{%")
assert.isEqual(macroBody[31], "  \\directlua{")
assert.isEqual(macroBody[32], "    thirddata.literateProgs.setCodeStream(")
assert.isEqual(macroBody[33], "      'Test',")
assert.isEqual(macroBody[34], "      '#1'")
assert.isEqual(macroBody[35], "    )")
assert.isEqual(macroBody[36], "  }")
assert.isEqual(macroBody[37], "}")
assert.isEqual(macroBody[38], "\\unexpanded\\def\\prependTest#1{%")
assert.isEqual(macroBody[39], "  \\directlua{")
assert.isEqual(macroBody[40], "    thirddata.literateProgs.setPrepend(")
assert.isEqual(macroBody[41], "      'Test',")
assert.isEqual(macroBody[42], "      '#1'")
assert.isEqual(macroBody[43], "    )")
assert.isEqual(macroBody[44], "  }")
assert.isEqual(macroBody[45], "}")
\stopLuaTest
\stopTestCase

\startTestCase[all fixed macros should exist]

\startConTest
\begingroup
  \defineLitProgs[Test]
  \assertDefined{oldStartTest}{}
  \assertDefined{startTest}{}
  \assertDefined{oldStopTest}{}
  \assertDefined{stopTest}{}
  \assertDefined{createTestFile}{}
  \assertDefined{setTestStream}{}
\endgroup
\stopConTest
\stopTestCase

We now turn to the lua code used in the \type{\directlua} commands above. 
As defined in the preamble, \type{litProgs} and \type{code} are variables 
local to the \type{t-literateProgs.lua} file. They provide access to the 
collection of lua functions and code fragments respectively. 

\startLuaCode
local function setOriginMarker(aCodeType, aCodeStream, anOriginMarker)
  if type(litProgs[anOriginMarker]) == 'function' then
    code[aCodeType] = code[aCodeType] or { }
    local codeType  = code[aCodeType]
    if aCodeStream then
      codeType[aCodeStream] = codeType[aCodeStream] or { }
      local codeStream = codeType[aCodeStream]
      codeStream['markOrigin'] = litProgs[anOriginMarker]
    else
      codeType['markOrigin'] = litProgs[anOriginMarker]
    end
  end
end

litProgs.setOriginMarker = setOriginMarker

local function markCodeOrigin(aCodeType)
  code[aCodeType]        = code[aCodeType] or { }
  local codeType         = code[aCodeType]
  codeType.curCodeStream = codeType.curCodeStream or 'default'
  local aCodeStream      = codeType.curCodeStream
  codeType[aCodeStream]  = codeType[aCodeStream] or { }
  local codeStream       = codeType[aCodeStream]
  codeStream.fileName    = status.filename
  codeStream.startLine   = status.linenumber
end

litProgs.markCodeOrigin = markCodeOrigin

local function setCodeStream(aCodeType, aCodeStream)
  code[aCodeType]        = code[aCodeType] or { }
  local codeType         = code[aCodeType]
  aCodeStream            = aCodeStream or 'default'
  codeType.curCodeStream = aCodeStream
end

litProgs.setCodeStream = setCodeStream

local function setPrepend(aCodeType, aCodeStream)
  code[aCodeType]        = code[aCodeType] or { }
  local codeType         = code[aCodeType]
  aCodeStream            = aCodeStream or 'default'
  codeType.curCodeStream = aCodeStream
  codeType[aCodeStream]  = codeType[aCodeStream] or { }
  local codeStream       = codeType[aCodeStream]
  codeStream.prepend     = true
end

litProgs.setPrepend = setPrepend

local function addCode(aCodeType, bufferName)
  local bufferContents  =
    buffers.getcontent(bufferName):gsub("\13", "\n")

  code[aCodeType]       = code[aCodeType] or { }
  local codeType        = code[aCodeType]
  local aCodeStream     = codeType.curCodeStream or 'default'
  codeType[aCodeStream] = codeType[aCodeStream] or { }
  local codeStream      = codeType[aCodeStream]

  local codeOrigin      = nil
    if type(codeStream['markOrigin']) == 'function' then
      codeOrigin =
        codeStream['markOrigin'](codeStream, aCodeType, aCodeStream)
    elseif type(codeType['markOrigin']) == 'function' then
      codeOrigin =
        codeType['markOrigin'](codeStream, aCodeType, aCodeStream)
    end

  if codeStream.prepend then
    tInsert(codeStream, 1, bufferContents)
    if codeOrigin then 
      tInsert(codeStream, 1, codeOrigin)
    end
  else
    if codeOrigin then
      tInsert(codeStream, codeOrigin)
    end
    tInsert(codeStream, bufferContents)
  end
  codeStream.prepend = nil
end

litProgs.addCode = addCode
\stopLuaCode

\startMkIVCode
\unexpanded\def\setLitProgsOriginMarker{%
  \dotripleempty\doSetLitProgsOriginMarker%
}

\unexpanded\def\doSetLitProgsOriginMarker[#1][#2][#3]{%
  \ifthirdargument%
    \directlua{
      thirddata.literateProgs.setOriginMarker('#1', '#2', '#3')
    }
  \else\ifsecondargument%
    \directlua{
      thirddata.literateProgs.setOriginMarker('#1', nil, '#2')
    }
  \else\iffirstargument%
    \errmessage{
      \string\\setLitProgsOriginMarker
      requires at least two arguments,
      you have only provided one.
    }
  \else%
    \errmessage{
      \string\\setLitProgsOriginMarker
      requires at least two arguments,
      you have provided none.
    }
  \fi\fi\fi%
}
\stopMkIVCode

\startTestCase[should be able to collect code I]

This test case is tested in two parts, part I and part II.

In this part we test the \ConTeXt\ level behaviour of the \quote{TestCode} 
environment. 

\startConTest
\begingroup
  \defineLitProgs[TestCode]
  \traceContextMacro{doStartTestCode}{1}
  \startTestCode
    this is some test "code"
  \stopTestCode
\endgroup
\stopConTest
\stopTestCase

\startTestCase[should be able to collect code II]

In this second part, we test the Lua level behaviour of the 
\quote{TestCode} environment. We are actively using the fact that the use 
of the \quote{TestCode} environment in the previous part of this extended 
test case, has left over side-effects, which we can now detect, in the Lua 
\type{code} data structure. 

\startLuaTest
  local code = thirddata.literateProgs.code
  assert.isNotNil(code['TestCode'], 'code')
  assert.isEqual(code['TestCode'].curCodeStream, 'default')
  code = code['TestCode']
  assert.isNotNil(code['default'], 'TestCode')
  code = code['default']
  assert.length(code, 1)
  assert.isEqual(code[1], 'this is some test "code"')
\stopLuaTest
\stopTestCase

\startLuaCode
function litProgs.createCodeFile(aCodeType,
                                 aCodeStream,
                                 aFilePath,
                                 aFileHeader)
  local theCode = code[aCodeType]
  if #aCodeStream < 1 then aCodeStream = 'default' end
  if theCode then theCode = theCode[aCodeStream] end
  if theCode and 0 < #aFilePath then
    local outFile = io.open(aFilePath, 'w')
    if 0 < #aFileHeader then
      if aFileHeader:match('[Cc][Oo][Nn][Tt][Ee][Xx][Tt]') then
        outFile:write('% ')
      end
      outFile:write(aFileHeader)
      outFile:write('\n\n')
    end
    outFile:write(tConcat(theCode, '\n\n'))
    outFile:close()
  end
end
\stopLuaCode

\stopTestSuite

\startMkIVCode
\defineLitProgs[MkIVCode][option=context]
\defineLitProgs[LuaCode][option=lua]
\defineLitProgs[LuaTemplate][option=lua]
\defineLitProgs[CHeader][option=cpp]
\defineLitProgs[CCode][option=cpp]
\defineLitProgs[Lakefile][option=lua]

\setLitProgsOriginMarker[MkIVCode][markMkIVCodeOrigin]
\setLitProgsOriginMarker[LuaCode][markLuaCodeOrigin]
\setLitProgsOriginMarker[LuaTemplate][markLuaTemplateOrigin]
\setLitProgsOriginMarker[CHeader][markCHeaderOrigin]
\setLitProgsOriginMarker[CCode][markCCodeOrigin]
\stopMkIVCode

% Do we need the following?

% Having defined a new code type in the previous section, we now have the 
% very much simpler task of providing a \type{\setupXXX} command. At the 
% moment we do not provide any extra options other than those provided by 
% the \type{\setuptyping} command. This means that all we have to do is to 
% define the \type{\setupXXX} to be a simple call to the 
% \type{\setuptyping} command. In all cases the \type{\setupXXX} will have 
% a single manditory argument which provides the collection 
% \type{\setuptyping} options to be used by this code type. 

%\startMkIVCode
%\def\defineLitProgsSetup#1{%
%  \def\csname setup#1\endcsname{%
%    \setuptyping[#1]%
%  }
%}
%\stopMkIVCode

\section{Test case results}

\reportMkIVStats

\reportLuaStats

\reportFailures

\stopchapter